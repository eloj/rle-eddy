#include <stdio.h>
#include <stdint.h>
#include <assert.h>
#include <string.h>

// TODO:
// * Need way to validate a cmd... you can't encode "CPY 140" .. return rle8, take err ptr, separate function?

typedef struct rle8 (*rle8_decode_fp)(uint8_t input);
typedef uint8_t (*rle8_encode_fp)(struct rle8 cmd);

static int opt_usage, opt_genc;

static const char *gen_header = "// Generated by rle-genops from https://github.com/eloj/rle-zoo\n";

struct rle_parser {
	const char *name;
	// params: max/min CPY/REP
	rle8_encode_fp rle8_encode;
	rle8_decode_fp rle8_decode;
};

enum RLE_OP {
	RLE_OP_CPY,
	RLE_OP_REP,
	RLE_OP_NOP,
	RLE_OP_INVALID,
};

struct rle8 {
	enum RLE_OP op;
	uint8_t cnt;
};

static const char *rle_op_cstr(enum RLE_OP op) {
	const char *res = "UNKNOWN";
	if (op == RLE_OP_CPY)
		res = "CPY";
	else if (op == RLE_OP_REP)
		res = "REP";
	else if (op == RLE_OP_NOP)
		res = "NOP";
	else if (op == RLE_OP_INVALID)
		res = "INVALID";
	return res;
}

static struct rle8 rle8_decode_packbits(uint8_t input) {
	struct rle8 cmd;

	if (input > 128) {
		cmd.op = RLE_OP_REP;
		cmd.cnt = 1 - (int8_t)input;
	} else if (input < 128) {
		cmd.op = RLE_OP_CPY;
		cmd.cnt = input + 1;
	} else {
		cmd.op = RLE_OP_NOP;
		cmd.cnt = 1;
	}

	assert(cmd.cnt > 0);
	assert(cmd.cnt <= 128);
#if 0
	... not the way to do this, REP 1 also invalid for this format.
	if (cmd.cnt == 0 || cmd.cnt > 128) {
		cmd.op = RLE_OP_INVALID;
	}
#endif

	return cmd;
}

static uint8_t rle8_encode_packbits(struct rle8 cmd) {
	uint8_t res;

	assert(cmd.op == RLE_OP_CPY || cmd.op == RLE_OP_REP || cmd.op == RLE_OP_NOP);
	assert(cmd.cnt > 0);
	assert(cmd.cnt <= 128);

	if (cmd.op == RLE_OP_REP) {
		res = 257 - cmd.cnt; // 1 - (int8_t)cmd.cnt;
	} else if (cmd.op == RLE_OP_CPY) {
		res = cmd.cnt - 1;
	} else if (cmd.op == RLE_OP_NOP) {
		res = 0x80;
	}

	return res;
}

static struct rle8 rle8_decode_goldbox(uint8_t input) {
	struct rle8 cmd;

	if (input & 0x80) {
		cmd.op = RLE_OP_REP;
		cmd.cnt = (~input) + 1;
	} else {
		cmd.op = RLE_OP_CPY;
		cmd.cnt = input + 1;
	}

	assert(cmd.cnt > 0);
	assert(cmd.cnt <= 128);

	return cmd;
}

static uint8_t rle8_encode_goldbox(struct rle8 cmd) {
	uint8_t res;

	assert(cmd.op == RLE_OP_CPY || cmd.op == RLE_OP_REP);
	assert(cmd.cnt > 0);
	assert(cmd.cnt <= 128);

	if (cmd.op == RLE_OP_REP) {
		res = 1 + (~cmd.cnt);
	} else if (cmd.op == RLE_OP_CPY) {
		res = cmd.cnt - 1;
	}

	return res;
}

static int rle8_generate_ops(struct rle_parser *p) {
	printf("// Automatically generated code table for RLE8 variant '%s'\n", p->name);
	printf("%s", gen_header);
	for (int i=0 ; i < 256 ; ++i) {
		uint8_t b = i;

		struct rle8 cmd = p->rle8_decode(b);
		uint8_t b_recode = p->rle8_encode(cmd);

		printf("0x%02x (%d/%d) => %s %d\n", b, b, (int8_t)b, rle_op_cstr(cmd.op), cmd.cnt);

		if (b != b_recode) {
			printf("ERROR: reencode mismatch: %s %d => 0x%02x\n", rle_op_cstr(cmd.op), cmd.cnt, b_recode);
			return 1;
		}
	}
	return 0;
}

static void rle8_generate_decode_table(struct rle_parser *p) {
	printf("\n// Decode table for RLE8 variant '%s'\n", p->name);

	printf("static struct rle8 rle8_tbl_decode_%s[256] = {\n ", p->name);

	for (int i=0 ; i < 256 ; ++i) {
		uint8_t b = i;
		struct rle8 cmd = p->rle8_decode(b);
		printf("{ RLE_OP_%s, %d }", rle_op_cstr(cmd.op), cmd.cnt);
		if (i < 255) printf(",");
		if ((i < 255) && ((i+1) % 8) == 0) printf("\n ");
	}

	printf("\n};\n");
}

static void rle8_generate_encode_tables(struct rle_parser *p) {
	printf("\n// Encode tables for RLE8 variant '%s'\n", p->name);

	// TODO: This should be autodetected by max of valid encodings.. rest of table filled out as -1 (invalid)
	int max_len = 1 + 128;
	printf("static int rle8_tbl_encode_%s[][%d] = {\n", p->name, max_len);

	printf(" // RLE_OP_CPY\n");
	printf(" { -1");
	for (int i=1 ; i < max_len ; ++i) {
		struct rle8 cmd = { RLE_OP_CPY, i };
		// TODO: need way to validate a cmd... you can't encode "CPY 140" .. return rle8?
		uint8_t code = p->rle8_encode(cmd);
		printf(", 0x%02x", code);
	}
	printf(" },\n");

	printf(" // RLE_OP_REP\n");
	printf(" { -1");
	for (int i=1 ; i < max_len ; ++i) {
		struct rle8 cmd = { RLE_OP_REP, i };
		uint8_t code = p->rle8_encode(cmd);
		printf(", 0x%02x", code);
	}
	printf(" },");

	printf("\n};\n");
}

static void rle8_generate_c_tables(struct rle_parser *p) {
	printf("%s", gen_header);

	rle8_generate_decode_table(p);
	rle8_generate_encode_tables(p);
}

struct rle_parser parsers[] = {
	{
		"goldbox",
		rle8_encode_goldbox,
		rle8_decode_goldbox
	},
	{
		"packbits",
		rle8_encode_packbits,
		rle8_decode_packbits
	}
};
static const size_t NUM_VARIANTS = sizeof(parsers)/sizeof(parsers[0]);

static struct rle_parser* get_parser_by_name(const char *name) {
	for (size_t i = 0 ; i < NUM_VARIANTS ; ++i) {
		if (strcmp(name, parsers[i].name) == 0) {
			return &parsers[i];
		}
	}
	return NULL;
}

static void print_variants(void) {
	printf("\nAvailable variants:\n");
	struct rle_parser *p = parsers;
	for (size_t i = 0 ; i < NUM_VARIANTS ; ++i) {
		printf("  %s\n", p->name);
		++p;
	}
}

static void usage(const char *argv) {
	printf("%s [OPTION] <variant>\n\n", argv);

	printf("Options:\n");
	printf("  --genc - Generate C tables.\n");

	print_variants();
}

static int parse_args(int *argc, char ***argv) {
	const char *arg = NULL;
	char **l_argv = *argv + 1;
	int l_argc = *argc - 1;
	int retval = 0;

	while ((arg = *l_argv) != NULL) {
		// "argv[argc] shall be a null pointer", section 5.1.2.2.1
		// const char *value = *l_argv;

		if (arg[0] == '-') {
			++l_argv;
			--l_argc;
			++arg;

			if (arg[0] == '-') {
				// long option
				++arg;
				if (strcmp(arg, "help") == 0) {
					opt_usage = 1;
				} else if (strcmp(arg, "genc") == 0) {
					opt_genc = 1;
				} else {
					retval = 1;
					break;
				}
			} else {
				// short option
				if (strcmp(arg, "h") == 0) {
					opt_usage = 1;
				} else {
					retval = 1;
					break;
				}
			}
		} else {
			break;
		}
	}

	if (retval != 0) {
		fprintf(stderr, "%s: unrecognized option: --%s\n", *argv[0], arg);
		fprintf(stderr, "Try '%s --help' for more information.\n", *argv[0]);
	}

	*argc = l_argc;
	*argv = l_argv;

	return retval;
}

int main(int argc, char *argv[]) {
	char **org_argv = argv;

	if (parse_args(&argc, &argv) != 0) {
		return 1;
	}

	if (opt_usage) {
		usage(org_argv[0]);
		return 1;
	}

	char *variant = argv[0];
	struct rle_parser *p = argc > 0 ? get_parser_by_name(variant) : NULL;

	if (!p) {
		if (variant) {
			fprintf(stderr, "error: Unknown variant '%s'\n", variant);
			print_variants();
		} else {
			usage(org_argv[0]);
		}
		return 2;
	}

	if (opt_genc)
		rle8_generate_c_tables(p);
	else
		rle8_generate_ops(p);

	return 0;
}
